/// taken from https://github.com/ikod/timingwheels
/// license: BSL-1.0
/+
 Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software is furnished to do so, all subject to the following:

The copyright notices in the Software and this entire statement, including the above license grant, this restriction and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all derivative works of the Software, unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 +/
module concurrency.timingwheels;

import std.datetime;
import std.exception;
import std.typecons;
import std.format;
import std.traits;
import std.range;
import std.algorithm;
import std.experimental.logger;

import core.thread;
import core.memory;

import std.typecons : Nullable, nullable;

pragma(inline)
private void dl_insertFront(L)(L* le, L** head) {
	if (*head == null) {
		le.next = le.prev = le;
	} else {
		auto curr_head = *head;
		le.prev = curr_head.prev;
		le.next = curr_head;
		curr_head.prev.next = le;
		curr_head.prev = le;
	}

	*head = le;
}

pragma(inline)
private void dl_unlink(L)(L* le, L** head) in(*head != null) {
	if (le.next == le && *head == le) {
		*head = null;
		return;
	}

	if (le == *head) {
		*head = le.next;
	}

	le.next.prev = le.prev;
	le.prev.next = le.next;
}

pragma(inline)
private void dl_walk(L)(L** head) {
	if (*head == null) {
		return;
	}

	auto le = *head;
	do {
		le = le.next;
	} while (le != *head);
}

pragma(inline)
private void dl_relink(L)(L* le, L** head_from, L** head_to)
		in(le.prev !is null && le.next !is null) {
	dl_unlink(le, head_from);
	dl_insertFront(le, head_to);
}

@("dl")
@safe unittest {
	struct LE {
		int p;
		LE* next;
		LE* prev;
	}

	LE* head1 = null;
	LE* head2 = null;
	auto le1 = new LE(1);
	auto le2 = new LE(2);
	dl_insertFront(le1, &head1);
	assert(head1 != null);
	dl_unlink(le1, &head1);
	assert(head1 == null);

	dl_insertFront(le1, &head1);
	assert(head1 != null);
	dl_insertFront(le2, &head1);
	dl_unlink(le1, &head1);
	assert(head1 != null);
	dl_unlink(le2, &head1);
	assert(head1 == null);

	dl_insertFront(le1, &head1);
	assert(head1 != null);
	dl_insertFront(le2, &head1);
	dl_unlink(le2, &head1);
	assert(head1 != null);
	dl_unlink(le1, &head1);
	assert(head1 == null);

	dl_insertFront(le1, &head1);
	dl_relink(le1, &head1, &head2);
	assert(head1 == null);
	assert(head2 != null);
}

///
/// This structure implements scheme 6.2 thom the
/// $(LINK http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf)
/// and supports several primitives:
/// $(UL
/// $(LI schedule timer in the future.)
/// $(LI cancel timer.)
/// $(LI time step (advance) - all timers expired at current time tick are extracted from wheels.)
/// )
/// Each operation take O(1) time.
///

struct ListElement(T) {
	T userdata;
	ulong scheduled_at;
	ushort position = 0xffff;
	ListElement!T* prev, next;
}

struct TimingWheels(T) {
	import core.bitop : bsr;

	package(concurrency) {
		enum MASK = 0xff;
		enum LEVELS = 8;
		enum LEVEL_MAX = LEVELS - 1;
		enum SLOTS = 256;

		struct Slot {
			ListElement!T* head;
		}

		struct Level {
			// now if counter of ticks processed on this level
			ulong now;
			Slot[SLOTS] slots;
		}

		Level[LEVELS] levels;
		ulong totalTimers;
		long startedAt;
	}

	alias Ticks = ulong; // ticks are 64 bit unsigned integers.

	// hashing ticks to slots
	// 8 levels, each level 256 slots, with of slot on each level 256 times
	// translate ticks to level
	// 0x00_00_00_00_00_00_00_00 <- ticks
	//   ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓
	//   □  □  □  □  □  □  □  □ \
	//   □  □  □  □  □  □  □  □ |
	//   .  .  .  .  .  .  .  . | 256 slots
	//   .  .  .  .  .  .  .  . |
	//   □  □  □  □  □  □  □  □ /
	//   7  6  5  4  3  2  1  0
	//                          <- 8 levels
	// each slot - double linked list of timers

	// ticks to level = bsr(ticks)/8
	pragma(inline)
	private pure int t2l(ulong t) @safe @nogc nothrow {
		if (t == 0) {
			return 0;
		}

		return bsr(t) / LEVELS;
	}

	// ticks to slot  = ticks >> (level*8)
	pragma(inline)
	private pure int t2s(ulong t, int l) @safe @nogc nothrow {
		return (t >> (l << 3)) & MASK;
	}

	// level to ticks
	// l[0] -> 256
	// l[1] -> 256*256
	// ...
	pragma(inline)
	private pure ulong l2t(int l) @safe @nogc nothrow {
		return SLOTS << l;
	}

	~this() {
		// ptrs.clear;
		for (int l = 0; l <= LEVEL_MAX; l++)
			for (int s = 0; s < SLOTS; s++) {
				while (levels[l].slots[s].head) {
					auto le = levels[l].slots[s].head;
					dl_unlink(le, &levels[l].slots[s].head);
					// () @trusted {
					// 	dispose(allocator, le);
					// }();
				}
			}
	}

	void initialize() {
		startedAt = Clock.currStdTime;
	}

	void initialize(ulong time) {
		startedAt = time;
	}

	/++ 
     + Return internal view on current time - it is time at the call to $(B init)
     + plus total number of steps multiplied by $(B tick) duration.
     + Params:
     +   tick = tick duration
     +/
	auto currStdTime(Duration tick) {
		return startedAt + levels[0].now * tick.split!"hnsecs".hnsecs;
	}

	///
	/// Schedule timer to $(B ticks) ticks forward from internal 'now'.
	///Params:
	/// timer = timer to schedule;
	/// ticks = ticks in the future to schedule timer. (0 < ticks < ulong.max);
	///Returns:
	///  void
	///Throws:
	/// ScheduleTimerError
	///   when thicks == 0
	///   or when timer already scheduled
	///
	bool schedule(ListElement!(T)* timer, ulong ticks) {
		if (ticks == 0) {
			ticks = 1;
		}

		if (timer.position != 0xffff)
		    return false;

		size_t level_index = 0;
		long t = ticks;
		long s = 1; // width of the slot in ticks on level
		long shift = 0;
		while (t > s << 8) // while t > slots on level
		{
			t -= (SLOTS - (levels[level_index].now & MASK)) * s;
			level_index++;
			s = s << 8;
			shift += 8;
		}

		auto level = &levels[level_index];
		auto mask = s - 1;
		size_t slot_index =
			(level.now + (t >> shift) + ((t & mask) > 0 ? 1 : 0)) & MASK;
		auto slot = &levels[level_index].slots[slot_index];
		timer.position = ((level_index << 8) | slot_index) & 0xffff;
		timer.scheduled_at = levels[0].now + ticks;
		dl_insertFront(timer, &slot.head);

		totalTimers++;
		return true;
	}

	/// Cancel timer
	///Params:
	/// timer = timer to cancel
	///Returns:
	/// bool if timer was found and removed
	bool cancel(ListElement!(T)* timer) {
		if (timer.position == 0xffff)
		    return false;

		immutable level_index = timer.position >> 8;
		immutable slot_index = timer.position & 0xff;
		debug(timingwheels)
			safe_tracef("cancel timer, l:%d, s:%d", level_index, slot_index);
		dl_unlink(timer, &levels[level_index].slots[slot_index].head);
		totalTimers--;

		return true;
	}

	/// Number of ticks to rotate wheels until internal wheel 'now'
	/// catch up with real world realTime.
	/// Calculation based on time when wheels were stared and total
	/// numer of ticks pasded.
	///Params:
	/// tick = your tick length (Duration)
	/// realTime = current real world now (Clock.currStdTime)
	///Returns: ticks to advance so that we catch up real world current time
	int ticksToCatchUp(Duration tick, ulong realTime) {
		auto c = startedAt + tick.split!"hnsecs".hnsecs * levels[0].now;
		auto v = (realTime - c) / tick.split!"hnsecs".hnsecs;
		if (v > 256) {
			return 256;
		}

		return cast(int) v;
	}

	/// Time until next scheduled timer event.
	/// You provide tick size and current real world time.
	/// This function find ticks until next event and use time of the start and
	/// total steps executed to calculate time delta from $(B realNow) to next event.
	///Params:
	/// tick = your accepted tick duration.
	/// realNow = real world now, result of Clock.currStdTime
	///Returns: time until next event. Can be zero or negative in case you have already expired events.
	///
	Nullable!Duration timeUntilNextEvent(const Duration tick, ulong realNow) {
		assert(startedAt > 0, "Forgot to call init()?");
		if (totalTimers == 0)
			return typeof(return).init;
		immutable n = ticksUntilNextEvent();
		immutable target =
			startedAt + (levels[0].now + n) * tick.split!"hnsecs".hnsecs;
		auto delta = (target - realNow).hnsecs;
		return nullable(delta);
	}

	///
	/// Adnvance wheel and return all timers expired during wheel turn.
	//
	/// Params:
	///   ticks = how many ticks to advance. Must be in range 0 <= 256
	/// Returns: amount of ticks actually advanced
	///
	ulong advance(this W)(ulong ticks, ref ListElement!T* head) {
		auto max = l2t(0);
		if (ticks > max) {
			ticks = max;
		}

		if (ticks == 0) {
			ticks = 1;
		}

		auto advanced = ticks;

		auto level = &levels[0];
		head = null;

		while (ticks) {
			ticks--;
			immutable now = ++level.now;
			immutable slot_index = now & MASK;
			auto slot = &level.slots[slot_index];
			while (slot.head) {
				totalTimers--;
				auto le = slot.head;
				le.position = 0xffff;
				dl_unlink(le, &slot.head);
				if (head is null) {
					le.next = null;
					le.prev = null;
					head = le;
				} else {
					le.next = head;
					head.prev = le;
					head = le;
				}
			}

			if (slot_index == 0) {
				advance_level(1);
			}
		}
		return advanced;
	}

	//
	// ticks until next event on level 0 or until next wheel rotation
	// If you have empty ticks it is safe to sleep - you will not miss anything, just wake up
	// at the time when next timer have to be processed.
	//Returns: number of safe "sleep" ticks.
	//
	private int ticksUntilNextEvent() out(r; r <= 256) {
		int result = 1;
		auto level = &levels[0];
		immutable uint now = levels[0].now & MASK;
		auto slot = (now + 1) & MASK;
		//assert(level.slots[now].head == null);
		do {
			if (level.slots[slot].head != null) {
				break;
			}

			result++;
			slot = (slot + 1) & MASK;
		} while (slot != now);

		return min(result, 256 - now);
	}

	private void advance_level(int level_index) in(level_index > 0) {
		immutable now0 = levels[0].now;
		auto level = &levels[level_index];
		immutable now = ++level.now;
		immutable slot_index = now & MASK;
		auto slot = &level.slots[slot_index];
		while (slot.head) {
			auto listElement = slot.head;

			immutable delta = listElement.scheduled_at - now0;
			size_t lower_level_index = 0;
			long t = delta;
			size_t s = 1; // width of the slot in ticks on level
			size_t shift = 0;
			while (t > s << 8) // while t > slots on level
			{
				t -= (SLOTS - (levels[lower_level_index].now & MASK)) * s;
				lower_level_index++;
				s = s << 8;
				shift += 8;
			}

			auto mask = s - 1;
			size_t lower_level_slot_index = (levels[lower_level_index].now
				+ (t >> shift) + ((t & mask) > 0 ? 1 : 0)) & MASK;
			listElement.position =
				((lower_level_index << 8) | lower_level_slot_index) & 0xffff;
			dl_relink(
				listElement, &slot.head,
				&levels[lower_level_index].slots[lower_level_slot_index].head);
		}

		if (slot_index == 0 && level_index < LEVEL_MAX) {
			advance_level(level_index + 1);
		}
	}

	void reset() {
		this = TimingWheels!T();
	}
}

@("TimingWheels")
@safe unittest {
	import unit_threaded;
	alias Timer = ListElement!ulong;
	TimingWheels!ulong w;
	w.initialize();
	assert(w.t2l(1) == 0);
	assert(w.t2s(1, 0) == 1);
	immutable t = 0x00_00_00_11_00_00_00_77;
	immutable level = w.t2l(t);
	assert(level == 4);
	immutable slot = w.t2s(t, level);
	assert(slot == 0x11);
	Timer timer;
	() @safe {
		w.schedule(&timer, 2);
		assert(!w.schedule(&timer, 5));
		Timer* ts;
		assert(w.advance(1024, ts) == 256);
		w.cancel(&timer);
		w.advance(1, ts);
	}();
}

@("TimingWheels.2")
@trusted unittest {
	alias Timer = ListElement!ulong;
	TimingWheels!ulong w;
	Timer timer;
	Timer* timers;
	w.initialize();
	w.schedule(&timer, 1);
	auto r = w.advance(1, timers);
	assert(timers !is null);
	assert(timers.next is null);
	w.schedule(&timer, 256);
	r = w.advance(255, timers);
	assert(timers is null);
	r = w.advance(1, timers);
	assert(timers !is null);
	assert(timer.next is null);
	w.schedule(&timer, 256 * 256);
	int c;
	for (int i = 0; i < 256; i++) {
		r = w.advance(256, timers);
		c += timers !is null;
	}

	assert(c == 1);
}

@("rt")
@safe unittest {
	import unit_threaded;
	alias Timer = ListElement!ulong;
	TimingWheels!ulong w;
	Duration tick = 5.msecs;
	w.initialize();
	ulong now = Clock.currStdTime;
	assert(now - w.currStdTime(tick) < 5 * 10_000);
	now += (tick * 2).total!"hnsecs";
	assert((now - w.currStdTime(tick)) / 10_000 - (2 * tick).split!"msecs".msecs
		< 10);
	auto toCatchUp = w.ticksToCatchUp(tick, now);
	toCatchUp.shouldEqual(2);
	Timer* timers;
	auto t = w.advance(toCatchUp, timers);
	toCatchUp = w.ticksToCatchUp(tick, now);
	toCatchUp.shouldEqual(0);
}

@("cancel")
@trusted unittest {
	import unit_threaded;
	alias Timer = ListElement!ulong;
	TimingWheels!ulong w;
	w.initialize();
	Timer timer0;
	Timer timer1;
	w.schedule(&timer0, 256);
	w.schedule(&timer1, 256 + 128);
	Timer* timers;
	auto r = w.advance(255, timers);
	assert(timers is null);
	w.cancel(&timer0);
	r = w.advance(1, timers);
	assert(timers is null);
	w.cancel(&timer1);
}

@("ticksUntilNextEvent")
@trusted unittest {
	import unit_threaded;
	alias Timer = ListElement!ulong;
	TimingWheels!ulong w;
	w.initialize();
	auto s = w.ticksUntilNextEvent;
	assert(s == 256);
	Timer* timers;
	auto r = w.advance(s, timers);
	assert(timers is null);
	Timer t;
	w.schedule(&t, 50);
	s = w.ticksUntilNextEvent;
	assert(s == 50);
	r = w.advance(s, timers);
	assert(timers !is null);
	assert(timers.next is null);
}
